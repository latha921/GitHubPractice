Week - 2:
public void verifyExtCc1CountryAccess(ReqContext reqContext){
		String countryCode = reqContext.getDeducedCc();
		String searchTn  = reqContext.getTnToSearch();
		String npa = searchTn.substring(0,3);
		Long custId = reqContext.getCustId();
		String searchKey = custId+":"+countryCode+":"+npa;
		CustCc1CountryExt custCc1CountryExt = cacheContainer.retrieveValue(Constants.CUST_CC1_COUNTRY_EXT,searchKey);
        reqContext.setExtCtryAllowed(custCc1CountryExt != null);
    }

	public void verifyExtCountryAccess(ReqContext reqContext){
		String countryCode = reqContext.getDeducedCc();
		String searchTn  = reqContext.getTnToSearch();
		Long custId = reqContext.getCustId();
		String searchKey = custId+":"+countryCode;
		CustCountryExt custCountryExt = cacheContainer.retrieveValue(Constants.CUST_COUNTRY_EXT,searchKey);
        reqContext.setExtCtryAllowed(custCountryExt != null);
    }



import org.mockito.Mock;
import org.mockito.InjectMocks;
import org.mockito.MockitoAnnotations;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;

import static org.mockito.Mockito.*;

public class VerifyCountryAccessTest {

    @Mock
    private CacheContainer cacheContainer;

    @Mock
    private ReqContext reqContext;

    @Mock
    private CustCc1CountryExt custCc1CountryExt;

    @Mock
    private CustCountryExt custCountryExt;

    @InjectMocks
    private MyClassUnderTest myClassUnderTest;

    @BeforeMethod
    public void setup() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testVerifyExtCc1CountryAccess_CustCc1CountryExtExists() {
        String countryCode = "US";
        String searchTn = "1234567890";
        Long custId = 123L;
        String searchKey = custId + ":" + countryCode + ":" + searchTn.substring(0, 3);

        when(reqContext.getDeducedCc()).thenReturn(countryCode);
        when(reqContext.getTnToSearch()).thenReturn(searchTn);
        when(reqContext.getCustId()).thenReturn(custId);
        when(cacheContainer.retrieveValue(Constants.CUST_CC1_COUNTRY_EXT, searchKey)).thenReturn(custCc1CountryExt);

        myClassUnderTest.verifyExtCc1CountryAccess(reqContext);

        verify(reqContext).setExtCtryAllowed(true);
    }

    @Test
    public void testVerifyExtCc1CountryAccess_CustCc1CountryExtDoesNotExist() {
        String countryCode = "US";
        String searchTn = "1234567890";
        Long custId = 123L;
        String searchKey = custId + ":" + countryCode + ":" + searchTn.substring(0, 3);

        when(reqContext.getDeducedCc()).thenReturn(countryCode);
        when(reqContext.getTnToSearch()).thenReturn(searchTn);
        when(reqContext.getCustId()).thenReturn(custId);
        when(cacheContainer.retrieveValue(Constants.CUST_CC1_COUNTRY_EXT, searchKey)).thenReturn(null);

        myClassUnderTest.verifyExtCc1CountryAccess(reqContext);

        verify(reqContext).setExtCtryAllowed(false);
    }

    @Test
    public void testVerifyExtCountryAccess_CustCountryExtExists() {
        String countryCode = "US";
        String searchTn = "1234567890";
        Long custId = 123L;
        String searchKey = custId + ":" + countryCode;

        when(reqContext.getDeducedCc()).thenReturn(countryCode);
        when(reqContext.getTnToSearch()).thenReturn(searchTn);
        when(reqContext.getCustId()).thenReturn(custId);
        when(cacheContainer.retrieveValue(Constants.CUST_COUNTRY_EXT, searchKey)).thenReturn(custCountryExt);

        myClassUnderTest.verifyExtCountryAccess(reqContext);

        verify(reqContext).setExtCtryAllowed(true);
    }

    @Test
    public void testVerifyExtCountryAccess_CustCountryExtDoesNotExist() {
        String countryCode = "US";
        String searchTn = "1234567890";
        Long custId = 123L;
        String searchKey = custId + ":" + countryCode;

        when(reqContext.getDeducedCc()).thenReturn(countryCode);
        when(reqContext.getTnToSearch()).thenReturn(searchTn);
        when(reqContext.getCustId()).thenReturn(custId);
        when(cacheContainer.retrieveValue(Constants.CUST_COUNTRY_EXT, searchKey)).thenReturn(null);

        myClassUnderTest.verifyExtCountryAccess(reqContext);

        verify(reqContext).setExtCtryAllowed(false);
    }
}






















public void checkRowPortability(ReqContext reqContext){
		CBM cbm = reqContext.getBlockData();
		if(cbm!=null && cbm.getNpEnabled() != null &&  !cbm.getNpEnabled().equalsIgnoreCase("y")){
			if(!checkRowNpEnabled(reqContext)){
				reqContext.setQstat(Qstat.Q_STAT_NP_CORRECTION_NOT_SUPPORTED);
				reqContext.setNpdi(false);
			}
			else{
				reqContext.setQstat(Qstat.Q_STAT_NPDI_BLK_NOT_PORTABLE_COUNTRY_PORTABLE);
			}
		}
	}


//

@Test
public void testCheckRowPortability_CbmNull() {
    Mockito.when(mockReqContext.getBlockData()).thenReturn(null);

    serviceHandler.checkRowPortability(mockReqContext);

    Mockito.verify(mockReqContext, Mockito.never()).setQstat(Mockito.anyString());
    Mockito.verify(mockReqContext, Mockito.never()).setNpdi(Mockito.anyBoolean());
}

@Test
public void testCheckRowPortability_NpEnabledNull() {
    CBM mockCbm = Mockito.mock(CBM.class);
    Mockito.when(mockReqContext.getBlockData()).thenReturn(mockCbm);
    Mockito.when(mockCbm.getNpEnabled()).thenReturn(null);

    serviceHandler.checkRowPortability(mockReqContext);

    Mockito.verify(mockReqContext, Mockito.never()).setQstat(Mockito.anyString());
    Mockito.verify(mockReqContext, Mockito.never()).setNpdi(Mockito.anyBoolean());
}

@Test
public void testCheckRowPortability_NpEnabledNotY_CheckRowNpDisabled() {
    CBM mockCbm = Mockito.mock(CBM.class);
    Mockito.when(mockReqContext.getBlockData()).thenReturn(mockCbm);
    Mockito.when(mockCbm.getNpEnabled()).thenReturn("n");
    Mockito.when(serviceHandler.checkRowNpEnabled(mockReqContext)).thenReturn(false);

    serviceHandler.checkRowPortability(mockReqContext);

    Mockito.verify(mockReqContext).setQstat(Qstat.Q_STAT_NP_CORRECTION_NOT_SUPPORTED);
    Mockito.verify(mockReqContext).setNpdi(false);
}

@Test
public void testCheckRowPortability_NpEnabledNotY_CheckRowNpEnabled() {
    CBM mockCbm = Mockito.mock(CBM.class);
    Mockito.when(mockReqContext.getBlockData()).thenReturn(mockCbm);
    Mockito.when(mockCbm.getNpEnabled()).thenReturn("n");
    Mockito.when(serviceHandler.checkRowNpEnabled(mockReqContext)).thenReturn(true);

    serviceHandler.checkRowPortability(mockReqContext);

    Mockito.verify(mockReqContext).setQstat(Qstat.Q_STAT_NPDI_BLK_NOT_PORTABLE_COUNTRY_PORTABLE);
    Mockito.verify(mockReqContext, Mockito.never()).setNpdi(Mockito.anyBoolean());
}

@Test
public void testCheckRowPortability_NpEnabledY() {
    CBM mockCbm = Mockito.mock(CBM.class);
    Mockito.when(mockReqContext.getBlockData()).thenReturn(mockCbm);
    Mockito.when(mockCbm.getNpEnabled()).thenReturn("y");

    serviceHandler.checkRowPortability(mockReqContext);

    Mockito.verify(mockReqContext, Mockito.never()).setQstat(Mockito.anyString());
    Mockito.verify(mockReqContext, Mockito.never()).setNpdi(Mockito.anyBoolean());
}




Currently SIPIX GUI log files dont have file permission to read log files by mtail to scrape the error metrics. Below are the error logs from mtail application. Need to update the log files permissions to 644 from application level and changes should reflect on below prod hosts

ch03-enum-prod-sipix-lnp01
ch03-enum-prod-sipix-lnp02
dc15-enum-prod-sipix-lnp01
dc15-enum-prod-sipix-lnp02 

enum-mtail-1  | I1202 13:21:41.432080       1 tail.go:355] open /data/ENUM/logs/sipix-gui/sipix_gui.log: permission denied
enum-mtail-1  | I1202 13:21:41.432140       1 tail.go:355] open /data/ENUM/logs/sipix-gui/sipix_gui_general.log: permission denied


Cannot invoke "com.neustar.qi.cache.CacheContainer.retrieveValue(String, Object)" because "<local3>.cacheContainer" is null
java.lang.NullPointerException: Cannot invoke "com.neustar.qi.cache.CacheContainer.retrieveValue(String, Object)" because "<local3>.cacheContainer" is null
